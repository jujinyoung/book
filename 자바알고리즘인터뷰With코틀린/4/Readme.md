# 4장 자료형
### 원시 자료형과 참조 자료형

|  원시자료형  |  크기  |   참조자료형   |
|:-------:|:----:|:---------:|
|  byte   | 1바이트 |   Byte    |
|  short  | 2바이트 |   Short   |
|   int   | 4바이트 |  Integer  |
|  long   | 8바이트 |   Long    |
|  float  | 4바이트 |   Float   |
| double  | 8바이트 |  Double   |
| boolean | 1비트  |  Boolean  |
|  char   | 2바이트 | Character |

참조형은 toString 등 여러 메소드를 직접 가지고 있어 편리하게 여러 작업을 수행할 수 있지만 대부분 16바이트로 원시형에 비해 크기가 더 크다.<br>

#### + 큰 숫자를 표현하고 싶을 경우에는 BigInteger 자료형을 사용할 것

### 원시 자료형과 참조 자료형의 속도 비교
**원시 자료형**은 메모리 주소를 정확히 알아내 정확히 그곳에 들어 있는 값을 조회하면 된다. <br>
하지만 **참조 자료형**은 해당 메모리 주소에 실제로 값이 포함된 또 다른 주소가 기입되어 있고, 그 주소를 찾아서 값을 조회하는 명령을 내리는 등 부가적인 작업이 추가로 필요로 한다.

|              자료형              | 1억 개 삽입 속도 |     설명      |
|:-----------------------------:|:----------:|:-----------:|
|             int[]             |   128밀리초   |    가장빠름     |
|           Integer[]           |   847밀리초   |             |
|      ArrayList<Integer>       |  2791밀리초   |    가장느림     |
| ArrayList<Integer>(100000000) |   897밀리초   | 참조형과 동일 속도  |
* 정확한 속도는 시스템마다 차이가 존재
* 코딩 테스트에서는 이처럼 간단한 최적화로도 느린 속도를 많이 높일 수 있음

### 자바 컬렉션 프레임워크의 등장
#### 1. List: 순서대로 엘리먼트를 모아두는 모음집, 배열에 순서대로 쌓는 것과 비슷함
* ArrayList: 시퀀스형태의 엘리먼트를 동적 배열로 구현한 자료형
* LinkedList: 연결 리스트로 구현한 자료형
* Vector: 현재 자바에서는 더이상 사용X
#### 2. Set: List와 유사하지만 순서와 중복의 허용X
#### 3. Queue: 추후 자세히 다룰 예정
#### 4. Map: key, Value구조로 데이터를 저장하는 자료구조
* HashMap: 기본적인 해시 테이블 구조의 자료형, 입력순서 보장X
* LinkedHashMap: HashMap과 유사하나 입력순서 보장
* TreeMap: 값에 따라 순서를 정렬, 레드-블랙 트리로 구현되어 정렬 순서도 임의로 지정가능
* Hashtable: 현재 자바에서는 더이상 사용X

### 초기 자료형의 성능 문제
CPU코어 1개이던 자바 초기 시절에는 **동기화**(**synchronized**)를 모든 메서드에서 사용하기 때문에 현재의 멀티 코어 시대에서는 적합하지 않다.<br>
Vector, Hashtable, StringBuffer, Stack같은  **자료형은 코딩테스트에서는 더 이상 사용해선 안됨.**
* Vector -> List
* Hashtable -> HashMap, ConcurrentHashMap(동기화)
* StringBuffer -> StringBuilder
* Stack -> Deque
